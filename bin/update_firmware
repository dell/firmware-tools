#!/usr/bin/python
# vim:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:tw=0

  #############################################################################
  #
  # Copyright (c) 2005 Dell Computer Corporation
  # Dual Licenced under GNU GPL and OSL
  #
  #############################################################################
"""update_firmware:

usage:
    -h | --help         print this message
    -c | --config       Location of an additional config file to import
    -o | --over         Override config file option
"""

from __future__ import generators

# import arranged alphabetically
import locale
import os
import sys
import time

# these are replaced by autotools when installed.
__VERSION__="unreleased_version"
SYSCONFDIR=os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])),"..","etc")
PYTHONDIR=os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])),"..")
PKGPYTHONDIR=os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])),"..","firmwaretools")
PKGDATADIR=os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])),"..")
CONFDIR=os.path.join(SYSCONFDIR,"firmware")
# end build system subs

# import all local modules after this. This allows us to run from build tree
sys.path.insert(0,PYTHONDIR)

import firmwaretools.repository
import firmwaretools.package
import firmwaretools.pycompat
import firmwaretools.clifuncs
import firmwaretools.config

class CmdlineError(Exception):pass

def main():
    try:
        locale.setlocale(locale.LC_ALL, '')
    except locale.Error, e:
        # default to C locale if we get a failure.
        print >> sys.stderr, 'Failed to set locale, defaulting to C'
        locale.setlocale(locale.LC_ALL, 'C')

    try:
        cfg = firmwaretools.config.FTConfig(usage=__doc__, version=__VERSION__)
        cfg.add_option("--rpm", action="store_true", dest="rpm_mode", default=False, help="Used when running as part of an rpm \%post script.")
        cfg.add_option("-y", "--yes", action="store_const", const=0, dest="interactive", default=1, help="")
        cfg.add_option("-t", "--test", action="store_const", const=2, dest="interactive", default=1, help="")

        opts, args = cfg.parse(sys.argv[1:])

        if opts.rpm_mode:
            v = 'manual'
            if cfg.ini.has_option("main", "rpm_mode"):
                v = cfg.ini.get("main", "rpm_mode")
            if v != 'auto':
                print "Config does not specify automatic install during package install."
                print "Please run update_firmware manually to install updates."
                return 0

        print
        print "Searching storage directory for available BIOS updates..."
        r = firmwaretools.repository.Repository( cfg.ini.get("main", "storage_topdir") )
        firmwaretools.package.RepositoryPackage.mainIni = cfg.ini

        depFailures = {}
        def show_work(*args, **kargs):
            #print "Got callback: %s  %s" % (args, kargs)
            if kargs.get("what") == "found_package_ini":
                p = kargs.get("path")
                if len(p) > 50:
                    p = p[-50:]
                firmwaretools.pycompat.spinPrint("Checking: %s" % p)

            if kargs.get("what") == "fail_dependency_check":
                pkg = kargs.get("package")
                pkgName = "%s-%s" % (pkg.name, pkg.version)
                if pkg.conf.has_option("package", "limit_system_support"):
                    pkgName = pkgName + "-" + pkg.conf.get("package", "limit_system_support")
                kargs.get("cb")[1][pkgName] = (kargs.get("package"), kargs.get("reason"))

        updateSet = firmwaretools.repository.generateUpdateSet(r, firmwaretools.clifuncs.runInventory(cfg), cb=(show_work, depFailures) )
        print "\033[2K\033[0G"  # clear line
        needUpdate = 0
        for device in updateSet.iterDevices():
            print "Checking %s - %s" % (str(device), device.version)
            for availPkg in updateSet.iterAvailableUpdates(device):
                print "\tAvailable: %s - %s" % (availPkg.name, availPkg.version)

            pkg = updateSet.getUpdatePackageForDevice(device)
            if pkg is None:
                print "\tDid not find a newer package to install that meets all installation checks."
            else:
                print "\tFound Update: %s - %s" % (pkg.name, pkg.version)
                needUpdate = 1

        if depFailures:
            print
            print "Following packages could apply, but have dependency failures:"

        for pkg, reason in depFailures.values():
            print "\t%s - %s" % (pkg.name, pkg.version)
            print "\t\t REASON: %s" % reason

        if not needUpdate:
            print
            print "This system does not appear to have any updates available."
            print "No action necessary."
            print
            return 1
        else:
            print
            print "Found firmware which needs to be updated."
            print

        # if we get to this point, that means update is necessary.
        # any exit before this point means that there was an error, or no update
        # was necessary and should return non-zero
        if opts.interactive == 2:
            print
            print "Test mode complete."
            print
            return 0

        if opts.interactive == 1:
            print
            print "Please run the program with the '--yes' switch to enable BIOS update."
            print "   UPDATE NOT COMPLETED!"
            print
            return 0

        print "Running updates..."
        for pkg in updateSet.generateInstallationOrder():
            try:

                def statusFunc():
                    if pkg.getCapability('accurate_update_percentage'):
                        firmwaretools.pycompat.spinPrint("%s%% Installing %s - %s" % (pkg.getProgress() * 100, pkg.name, pkg.version))
                    else:
                        firmwaretools.pycompat.spinPrint("Installing %s - %s" % (pkg.name, pkg.version))
                    time.sleep(0.2)

                ret = firmwaretools.pycompat.runLongProcess(pkg.install, waitLoopFunction=statusFunc)
                print firmwaretools.pycompat.clearLine(),
                print "100%% Installing %s - %s" % (pkg.name, pkg.version)
                print "Done: %s" % pkg.getStatusStr()
                print

            except (firmwaretools.package.NoInstaller,), e:
                print "package %s - %s does not have an installer available." % (pkg.name, pkg.version)
                print "skipping this package for now."
                continue
            except (firmwaretools.package.InstallError,), e:
                print "Installation failed for package: %s - %s" % (pkg.name, pkg.version)
                print "aborting update..."
                print
                print "The error message from the low-level command was:"
                print
                print e
                break

    except Exception, e:
        import traceback
        from firmwaretools.trace_decorator import getLog
        getLog().debug(''.join(traceback.format_exception(sys.exc_type, sys.exc_value, sys.exc_traceback)))

        print
        print e
        print
        print __doc__
        sys.exit(2)

    return 0 #shell logic


if __name__ == "__main__":
    sys.exit( main() )

